
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { useLocation } from 'react-router-dom';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/contexts/AuthContext';

interface AIContextData {
  projects: any[];
  employees: any[];
  companies: any[];
  tasks: any[];
  devis: any[];
  invoices: any[];
  insights: any[];
  currentModule: string;
  contextualSuggestions: ContextualSuggestion[];
  isLoading: boolean;
  refreshContext: () => Promise<void>;
  addInsight: (insight: any) => void;
}

interface ContextualSuggestion {
  text: string;
  action: string;
  icon: string;
  module: string;
}

interface AIContextProviderProps {
  children: ReactNode;
}

const AIContext = createContext<AIContextData | undefined>(undefined);

export const AIContextProvider: React.FC<AIContextProviderProps> = ({ children }) => {
  const { user } = useAuth();
  const location = useLocation();
  
  const [contextData, setContextData] = useState({
    projects: [],
    employees: [],
    companies: [],
    tasks: [],
    devis: [],
    invoices: [],
    insights: []
  });
  
  const [isLoading, setIsLoading] = useState(true);
  const [contextualSuggestions, setContextualSuggestions] = useState<ContextualSuggestion[]>([]);

  // D√©terminer le module actuel
  const getCurrentModule = (): string => {
    const path = location.pathname;
    const userRole = user?.user_metadata?.role || 'client';
    
    if (path.includes('/dashboard')) {
      if (userRole === 'admin' || userRole === 'super_admin') return 'admin-dashboard';
      if (userRole === 'client') return 'client-dashboard';
      return 'dashboard';
    }
    if (path.includes('/projects')) return 'projects';
    if (path.includes('/hr')) return 'hr';
    if (path.includes('/business')) return 'business';
    if (path.includes('/synapse')) return 'synapse';
    return 'general';
  };

  // G√©n√©rer des suggestions contextuelles bas√©es sur les vraies donn√©es
  const generateContextualSuggestions = (module: string, data: any): ContextualSuggestion[] => {
    const suggestions: ContextualSuggestion[] = [];

    switch (module) {
      case 'dashboard':
      case 'admin-dashboard':
        const totalProjects = data.projects?.length || 0;
        const activeProjects = data.projects?.filter(p => p.status === 'in_progress').length || 0;
        const totalRevenue = data.invoices?.filter(i => i.status === 'paid').reduce((sum, i) => sum + (i.amount || 0), 0) || 0;
        
        suggestions.push(
          { text: `Analyser ${totalProjects} projets (${activeProjects} actifs)`, action: "analyze_projects", icon: "üìä", module },
          { text: `CA r√©alis√©: ${new Intl.NumberFormat('fr-FR', { style: 'currency', currency: 'XOF', minimumFractionDigits: 0 }).format(totalRevenue)}`, action: "revenue_analysis", icon: "üí∞", module },
          { text: "Pr√©dire performances Q2", action: "predict_performance", icon: "üîÆ", module }
        );
        break;

      case 'client-dashboard':
        const clientInvoices = data.invoices?.length || 0;
        const clientQuotes = data.devis?.length || 0;
        const clientProjects = data.projects?.length || 0;
        
        suggestions.push(
          { text: `${clientInvoices} factures √† suivre`, action: "review_invoices", icon: "üìã", module },
          { text: `${clientQuotes} devis re√ßus`, action: "review_quotes", icon: "üíº", module },
          { text: `${clientProjects} projets en cours`, action: "track_projects", icon: "üöÄ", module }
        );
        break;

      case 'projects':
        const delayedProjects = data.projects?.filter(p => p.status === 'in_progress' && new Date(p.end_date) < new Date()).length || 0;
        const totalTasks = data.tasks?.length || 0;
        const pendingTasks = data.tasks?.filter(t => t.status === 'todo').length || 0;
        
        suggestions.push(
          { text: `${delayedProjects} projets en retard`, action: "analyze_delays", icon: "‚ö†Ô∏è", module },
          { text: `${pendingTasks}/${totalTasks} t√¢ches en attente`, action: "optimize_tasks", icon: "‚úÖ", module },
          { text: "R√©organiser les priorit√©s", action: "reorganize_priorities", icon: "üìà", module }
        );
        break;

      case 'hr':
        const totalEmployees = data.employees?.length || 0;
        const activeEmployees = data.employees?.filter(e => e.employment_status === 'active').length || 0;
        
        suggestions.push(
          { text: `${activeEmployees}/${totalEmployees} employ√©s actifs`, action: "analyze_workforce", icon: "üë•", module },
          { text: "√âvaluer charge de travail", action: "workload_analysis", icon: "‚öñÔ∏è", module },
          { text: "Identifier talents √©mergents", action: "talent_detection", icon: "‚≠ê", module }
        );
        break;

      case 'business':
        const pendingQuotes = data.devis?.filter(d => d.status === 'sent' || d.status === 'pending').length || 0;
        const paidInvoices = data.invoices?.filter(i => i.status === 'paid').length || 0;
        const totalAmount = data.invoices?.reduce((sum, i) => sum + (i.amount || 0), 0) || 0;
        
        suggestions.push(
          { text: `${pendingQuotes} devis √† suivre`, action: "follow_quotes", icon: "üìù", module },
          { text: `${paidInvoices} factures pay√©es`, action: "payment_analysis", icon: "‚úÖ", module },
          { text: `CA total: ${new Intl.NumberFormat('fr-FR', { style: 'currency', currency: 'XOF', minimumFractionDigits: 0 }).format(totalAmount)}`, action: "revenue_breakdown", icon: "üíé", module }
        );
        break;

      default:
        suggestions.push(
          { text: "Analyser l'activit√© globale", action: "global_analysis", icon: "üåç", module },
          { text: "Suggestions personnalis√©es", action: "personalized_insights", icon: "üéØ", module }
        );
    }

    return suggestions;
  };

  // Charger toutes les donn√©es contextuelles selon le r√¥le utilisateur
  const refreshContext = async () => {
    if (!user) return;

    try {
      setIsLoading(true);
      const userRole = user?.user_metadata?.role || 'client';
      const userCompanyId = user?.user_metadata?.company_id;

      // Debug: log les valeurs pour identifier le probl√®me
      console.log('AIContextProvider - User role:', userRole);
      console.log('AIContextProvider - User company ID:', userCompanyId);
      console.log('AIContextProvider - User ID:', user.id);

      let projectsData, employeesData, companiesData, tasksData, devisData, invoicesData;

      if (userRole === 'admin' || userRole === 'super_admin') {
        // Admin : acc√®s √† toutes les donn√©es
        const results = await Promise.all([
          supabase.from('projects').select('*').limit(100),
          supabase.from('employees').select('*').limit(200),
          supabase.from('companies').select('*').limit(50),
          supabase.from('tasks').select('*').limit(500),
          supabase.from('devis').select('*').limit(100),
          supabase.from('invoices').select('*').limit(100)
        ]);
        
        [projectsData, employeesData, companiesData, tasksData, devisData, invoicesData] = results;
      } else if (userRole === 'client' && userCompanyId) {
        // Client : seulement ses donn√©es (uniquement si company_id existe)
        const results = await Promise.all([
          supabase.from('projects').select('*').eq('client_company_id', userCompanyId),
          Promise.resolve({ data: [] }),
          supabase.from('companies').select('*').eq('id', userCompanyId),
          supabase.from('tasks').select('*').limit(50),
          supabase.from('devis').select('*').eq('company_id', userCompanyId),
          supabase.from('invoices').select('*').eq('company_id', userCompanyId)
        ]);
        
        [projectsData, employeesData, companiesData, tasksData, devisData, invoicesData] = results;
      } else if (userRole === 'client' && !userCompanyId) {
        // Client sans company_id : donn√©es vides pour √©viter les erreurs
        console.warn('Client user without company_id, returning empty data');
        [projectsData, employeesData, companiesData, tasksData, devisData, invoicesData] = [
          { data: [] }, { data: [] }, { data: [] }, { data: [] }, { data: [] }, { data: [] }
        ];
      } else {
        // Employ√© : donn√©es limit√©es
        const results = await Promise.all([
          supabase.from('projects').select('*').limit(50),
          supabase.from('employees').select('*').limit(100),
          supabase.from('companies').select('*').limit(20),
          supabase.from('tasks').select('*').eq('assignee_id', user.id),
          Promise.resolve({ data: [] }),
          Promise.resolve({ data: [] })
        ]);
        
        [projectsData, employeesData, companiesData, tasksData, devisData, invoicesData] = results;
      }

      const newContextData = {
        projects: projectsData.data || [],
        employees: employeesData.data || [],
        companies: companiesData.data || [],
        tasks: tasksData.data || [],
        devis: devisData.data || [],
        invoices: invoicesData.data || [],
        insights: contextData.insights
      };

      setContextData(newContextData);

      // G√©n√©rer les suggestions contextuelles
      const currentModule = getCurrentModule();
      const suggestions = generateContextualSuggestions(currentModule, newContextData);
      setContextualSuggestions(suggestions);

    } catch (error) {
      console.error('Erreur lors du chargement du contexte IA:', error);
    } finally {
      setIsLoading(false);
    }
  };

  // Ajouter un insight
  const addInsight = (insight: any) => {
    setContextData(prev => ({
      ...prev,
      insights: [...prev.insights, { ...insight, id: Date.now(), timestamp: new Date().toISOString() }]
    }));
  };

  // Rafra√Æchir le contexte quand l'utilisateur ou la route change
  useEffect(() => {
    refreshContext();
  }, [user, location.pathname]);

  // Mettre √† jour les suggestions quand les donn√©es changent
  useEffect(() => {
    const currentModule = getCurrentModule();
    const suggestions = generateContextualSuggestions(currentModule, contextData);
    setContextualSuggestions(suggestions);
  }, [contextData, location.pathname]);

  // Mise √† jour temps r√©el des donn√©es toutes les 30 secondes
  useEffect(() => {
    if (!user) return;
    
    const interval = setInterval(() => {
      console.log('üîÑ Rafra√Æchissement automatique des donn√©es IA');
      refreshContext();
    }, 30000); // 30 secondes

    return () => clearInterval(interval);
  }, [user]);

  const value: AIContextData = {
    ...contextData,
    currentModule: getCurrentModule(),
    contextualSuggestions,
    isLoading,
    refreshContext,
    addInsight
  };

  return (
    <AIContext.Provider value={value}>
      {children}
    </AIContext.Provider>
  );
};

export const useAIContext = () => {
  const context = useContext(AIContext);
  if (context === undefined) {
    throw new Error('useAIContext must be used within an AIContextProvider');
  }
  return context;
};
